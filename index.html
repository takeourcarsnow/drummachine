<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>CHIP-TRAX — 8‑bit Drum Machine + Synth</title>
<style>
  :root{
    --bg:#0b0d12;
    --panel:#121826;
    --panel2:#0e1420;
    --ink:#e6e6e6;
    --ink-dim:#97a0aa;
    --fg:#62ff9b;      /* Neon green */
    --accent:#ff2e8b;  /* Hot magenta */
    --accent2:#00e0ff; /* Cyan */
    --warn:#ffdb4d;
    --gridA:#1a2233;
    --gridB:#0f1522;
    --on:#62ff9b;
    --on-acc:#98ffbe;
    --off:#27324a;
    --play:#ffdb4d;
    --shadow:#000000;
    --good:#00e28a;
    --bad:#ff667b;
  }
  *{box-sizing:border-box}
  html,body{
    background: var(--bg);
    color: var(--ink);
    margin:0;
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
    line-height:1.35;
    image-rendering: pixelated;
  }

  /* CRT/scanline vibe */
  body::after{
    content:"";
    pointer-events:none;
    position:fixed; inset:0;
    background:
      repeating-linear-gradient(
        to bottom,
        rgba(255,255,255,0.035) 0px,
        rgba(255,255,255,0.035) 1px,
        rgba(0,0,0,0) 2px,
        rgba(0,0,0,0) 3px
      );
    mix-blend-mode: overlay;
  }

  .wrap{
    max-width:1100px;
    margin:24px auto 64px;
    padding:0 16px;
  }

  .ascii{
    background:linear-gradient(180deg,var(--panel),var(--panel2));
    border:4px solid #000;
    box-shadow:
      0 0 0 2px #111,
      0 0 0 6px #000,
      0 20px 40px rgba(0,0,0,0.5);
    padding:16px;
    text-shadow: 0 0 8px rgba(98,255,155,0.25);
    color: var(--fg);
    overflow:auto;
  }
  .ascii pre{margin:0;font-size:12px;letter-spacing:1px}

  .row{
    display:flex; gap:16px; flex-wrap:wrap; align-items:flex-start; margin:18px 0;
  }

  .panel{
    background: linear-gradient(180deg,var(--panel),var(--panel2));
    border:4px solid #000;
    box-shadow: 0 0 0 2px #111, 0 0 0 6px #000;
    padding:12px;
  }

  .title{
    color: var(--accent2);
    text-shadow: 0 0 8px rgba(0,224,255,0.4);
    font-weight:700; letter-spacing:1px; margin-bottom:8px;
  }

  .controls{
    display:flex; flex-wrap:wrap; gap:10px; align-items:center;
  }
  .ctrl{
    display:flex; align-items:center; gap:6px; background:#0c1322; border:2px solid #000; padding:6px 8px; box-shadow: inset 0 0 0 2px #172036, 2px 2px 0 0 #000;
    border-radius:3px;
  }
  .ctrl label{color:var(--ink-dim); font-size:12px}
  .ctrl input[type="number"], .ctrl input[type="range"], .ctrl select{
    accent-color: var(--accent);
  }
  .ctrl input[type="number"]{
    width:70px; background:#0a1120; color:var(--ink); border:1px solid #000; padding:3px 6px; font-family:inherit;
  }
  .btn{
    background: linear-gradient(180deg,#0f1a2f,#0a1120);
    border:2px solid #000; box-shadow: inset 0 0 0 2px #172036, 2px 2px 0 0 #000;
    color:var(--ink);
    padding:8px 12px; cursor:pointer; font-weight:700; letter-spacing:1px;
    text-transform:uppercase; border-radius:4px;
  }
  .btn:hover{filter:brightness(1.1)}
  .btn:active{transform:translate(1px,1px)}

  .grid{
    display:grid;
    grid-template-columns: 140px repeat(16, 1fr);
    gap:6px;
    align-items:center;
  }
  .grid-head{
    margin-bottom:8px;
  }
  .step-head{
    width: 36px; height: 22px; display:flex; align-items:center; justify-content:center;
    color: var(--ink-dim);
    background: #0c1322;
    border:2px solid #000; box-shadow: inset 0 0 0 2px #172036, 2px 2px 0 0 #000;
    border-radius:4px;
    font-size:11px;
    user-select:none;
    pointer-events:none;
  }
  .step-head.even{background: #0a1020}

  .track-name{
    color: var(--fg);
    text-shadow: 0 0 8px rgba(98,255,155,0.25);
    font-weight:700; letter-spacing:1px; font-size:12px;
    display:flex; align-items:center; justify-content:space-between;
    gap:8px;
  }
  .track-name .ms{
    display:flex; gap:6px; align-items:center;
  }
  .toggle{
    display:inline-flex; align-items:center; justify-content:center;
    width:22px; height:22px; font-size:11px; font-weight:800; letter-spacing:.5px;
    border:1px solid #000; border-radius:3px;
    background:#0e1628; color:var(--ink-dim);
    box-shadow: inset 0 0 0 1px #1a2746, 2px 2px 0 #000;
    cursor:pointer; user-select:none;
  }
  .toggle:hover{filter:brightness(1.05)}
  .toggle.active{color:#fff; text-shadow:0 0 6px rgba(255,255,255,.25)}
  .toggle.m.active{background:#1b2c34; box-shadow: inset 0 0 0 1px #2a4858, 2px 2px 0 #000}
  .toggle.s.active{background:#2a1b34; box-shadow: inset 0 0 0 1px #51305d, 2px 2px 0 #000}

  .cell{
    width: 36px; height: 36px;
    background: var(--gridB);
    border:2px solid #000;
    box-shadow: inset 0 0 0 2px #16233d, 2px 2px 0 0 #000;
    position:relative; cursor:pointer; border-radius:4px;
    user-select:none;
  }
  .cell.even{background: var(--gridA)}
  .cell.active{background: var(--on); box-shadow: inset 0 0 0 2px #1a6138, 2px 2px 0 0 #000}
  .cell.active.accent{background: var(--on-acc); box-shadow: inset 0 0 0 2px #2d7a4e, 2px 2px 0 0 #000}
  .cell.playing::after{
    content:"";
    position:absolute; inset:-3px;
    border:3px solid var(--play);
    box-shadow: 0 0 10px var(--play), inset 0 0 8px var(--play);
    border-radius:6px; pointer-events:none;
  }

  .tiny{
    font-size:11px; color: var(--ink-dim);
  }

  .vol-row{
    display:flex; align-items:center; gap:8px; margin-top:6px; flex-wrap:wrap;
  }
  .vol-row input[type="range"]{width:140px}

  /* Synth keys */
  .keyboard{
    display:flex; position:relative; user-select:none;
    padding:10px; background:#0c1322; border:2px solid #000; box-shadow: inset 0 0 0 2px #172036, 2px 2px 0 0 #000;
    overflow:hidden;
  }
  .key{
    width:40px; height:140px; margin:0 3px; border:2px solid #000; box-shadow: inset 0 0 0 2px #2a395c, 2px 2px 0 0 #000;
    background:#cfd7e6; position:absolute; cursor:pointer; border-radius:3px;
  }
  .key.black{
    width:28px; height:92px; background:#151c2e;
    z-index:2;
    box-shadow: inset 0 0 0 2px #223054, 2px 2px 0 0 #000;
  }
  .key.down{filter:brightness(0.8); transform:translateY(1px)}
  .kb-wrap{position:relative; height: 150px}
  .kb-note{ position:absolute; }

  .help{
    color: var(--ink-dim); font-size:12px; margin-top:6px
  }

  .badge{
    display:inline-block; padding:2px 6px; border:1px solid #000; background:#0e1628; box-shadow: inset 0 0 0 1px #1a2746, 2px 2px 0 #000; border-radius:3px; color:var(--accent2); font-weight:700; letter-spacing:.5px
  }

  .footer{
    margin-top:28px; color:var(--ink-dim); font-size:12px; text-align:right;
  }

  .inline-note{
    margin-left:6px; color:var(--ink-dim); font-size:11px
  }

  .toast{
    position:fixed; left:50%; bottom:24px; transform:translateX(-50%);
    background:#0f182b; color:#fff; border:2px solid #000; border-radius:6px;
    box-shadow: inset 0 0 0 2px #1c2a4b, 6px 6px 0 #000;
    padding:8px 12px; font-weight:700; letter-spacing:.5px; z-index:999;
    opacity:0; transition:opacity .15s ease, transform .15s ease;
    pointer-events:none;
  }
  .toast.show{opacity:1; transform:translate(-50%, -2px)}

  /* Responsive small screens */
  @media (max-width: 900px){
    .grid{grid-template-columns: 100px repeat(16, minmax(20px, 1fr))}
    .step-head{width:24px; height:20px}
    .cell{width: 24px; height: 24px}
    .keyboard .key{height:100px; width:28px}
    .key.black{height:66px; width:20px}
  }
</style>
</head>
<body>
  <div class="wrap">
    <div class="ascii" aria-hidden="true">
<pre>
   ____ _   _ ___ ____   _____ ____  ____   _   _  __   __
  / ___| | | |_ _|  _ \ |_   _|  _ \|  _ \ | \ | | \ \ / /
 | |   | |_| || || |_) |  | | | |_) | |_) ||  \| |  \ V /
 | |___|  _  || ||  _ &lt;   | | |  __/|  _ &lt; | |\  |   | |
  \____|_| |_|___|_| \_\  |_| |_|   |_| \_\|_| \_|   |_|

   8-bit chiptune drum machine + mono synth • NES/ASCII vibe
   Space: Play/Stop • Z/S/X/D/C... = Keys • Click pads to toggle (Alt=Accent)
</pre>
    </div>

    <div class="row panel">
      <div class="title">Transport & Groove</div>
      <div class="controls">
        <button class="btn" id="playBtn" aria-label="Play/Stop">▶ Play</button>
        <button class="btn" id="tapBtn" title="Tap Tempo">Tap</button>
        <div class="ctrl" title="Beats Per Minute">
          <label for="bpm">BPM</label>
          <input type="range" id="bpm" min="40" max="240" value="120" />
          <input type="number" id="bpmNum" min="40" max="240" value="120" />
        </div>
        <div class="ctrl" title="Swing pairs of 16ths">
          <label for="swing">Swing</label>
          <input type="range" id="swing" min="0" max="0.6" step="0.01" value="0.0" />
          <span class="tiny" id="swingTxt">0%</span>
        </div>
        <div class="ctrl" title="Humanize timing and level">
          <label for="human">Humanize</label>
          <input type="range" id="human" min="0" max="30" step="1" value="0" />
          <span class="tiny" id="humanTxt">0ms</span>
        </div>
        <div class="ctrl" title="Randomize / Clear / Save / Load / Share">
          <label>Tools</label>
          <button class="btn" id="randomizeBtn">Randomize</button>
          <button class="btn" id="clearBtn">Clear</button>
          <button class="btn" id="saveBtn">Save</button>
          <button class="btn" id="loadBtn">Load</button>
          <button class="btn" id="shareBtn">Share</button>
        </div>
        <div class="ctrl">
          <label>Scale</label>
          <span class="badge">16 Steps • 4 Tracks</span>
          <span class="inline-note">Alt-click pad = accent</span>
        </div>
        <div class="ctrl" title="Master Volume">
          <label>Master</label>
          <input type="range" id="masterVol" min="0" max="1" step="0.01" value="0.9">
        </div>
      </div>
    </div>

    <div class="row panel">
      <div class="title">Drum Machine</div>

      <div class="grid grid-head" id="gridHead">
        <div class="track-name tiny" aria-hidden="true">STEP</div>
        <!-- numbers injected -->
      </div>

      <div class="grid" id="grid" aria-label="Drum grid">
        <!-- Rows injected -->
      </div>
      <div class="vol-row" aria-label="Track Volume">
        <span class="tiny">Track Volumes:</span>
        <span class="tiny" style="color:var(--fg); width:64px; display:inline-block">KICK</span><input type="range" min="0" max="1" step="0.01" value="0.9" id="vol0" aria-label="Kick Volume">
        <span class="tiny" style="color:var(--fg); width:64px; display:inline-block">SNARE</span><input type="range" min="0" max="1" step="0.01" value="0.8" id="vol1" aria-label="Snare Volume">
        <span class="tiny" style="color:var(--fg); width:64px; display:inline-block">HAT</span><input type="range" min="0" max="1" step="0.01" value="0.65" id="vol2" aria-label="Hat Volume">
        <span class="tiny" style="color:var(--fg); width:64px; display:inline-block">CLAP</span><input type="range" min="0" max="1" step="0.01" value="0.7" id="vol3" aria-label="Clap Volume">
      </div>
      <div class="help">Tips: Click pads to toggle. Alt/Option adds Accent. Yellow frame shows the playing step. Randomize for instant fun. Use M/S to Mute or Solo tracks.</div>
    </div>

    <div class="row panel" style="gap:24px">
      <div style="min-width:300px; flex:1">
        <div class="title">Chippy Synth</div>
        <div class="controls" style="gap:12px">
          <div class="ctrl">
            <label>Wave</label>
            <select id="waveSel">
              <option value="square">Square 50%</option>
              <option value="pulse25">Pulse 25%</option>
              <option value="pulse125">Pulse 12.5%</option>
              <option value="triangle">Triangle</option>
            </select>
          </div>
          <div class="ctrl">
            <label>Attack</label><input type="range" id="att" min="0" max="0.5" step="0.005" value="0.01">
          </div>
          <div class="ctrl">
            <label>Decay</label><input type="range" id="dec" min="0" max="1.5" step="0.01" value="0.15">
          </div>
          <div class="ctrl">
            <label>Sustain</label><input type="range" id="sus" min="0" max="1.0" step="0.01" value="0.6">
          </div>
          <div class="ctrl">
            <label>Release</label><input type="range" id="rel" min="0" max="2.0" step="0.01" value="0.2">
          </div>
          <div class="ctrl">
            <label>Glide</label><input type="range" id="glide" min="0" max="0.2" step="0.005" value="0.02">
          </div>
          <div class="ctrl" title="Bit depth waveshaper">
            <label>Bits</label><input type="range" id="bits" min="4" max="16" step="1" value="8">
          </div>
          <div class="ctrl" title="Low-pass filter cutoff">
            <label>Cutoff</label><input type="range" id="cut" min="200" max="12000" step="1" value="8000">
          </div>
          <div class="ctrl" title="Low-pass resonance (Q)">
            <label>Reso</label><input type="range" id="reso" min="0.1" max="12" step="0.1" value="0.7">
          </div>
          <div class="ctrl" title="Vibrato LFO">
            <label>Vib Hz</label><input type="range" id="vibRate" min="0" max="12" step="0.1" value="0">
          </div>
          <div class="ctrl" title="Vibrato depth (cents)">
            <label>Vib Cents</label><input type="range" id="vibDepth" min="0" max="80" step="1" value="0">
          </div>
          <div class="ctrl">
            <label>Oct</label><input type="number" id="oct" min="-2" max="3" value="0">
          </div>
          <div class="ctrl">
            <label>Vol</label><input type="range" id="synthVol" min="0" max="1" step="0.01" value="0.75">
          </div>
        </div>

        <div class="help">
          Keyboard: Z S X D C V G B H N J M , (C–C) and Q 2 W 3 E R 5 T 6 Y 7 U I (upper octave). Hold keys for glide.
        </div>
      </div>

      <div style="flex:1; min-width:320px">
        <div class="title">Keys</div>
        <div class="keyboard" id="keyboard">
          <div class="kb-wrap" id="kbwrap">
            <!-- dynamically positioned -->
            <!-- We'll layout one octave C..B with overlayed black keys -->
          </div>
        </div>
      </div>
    </div>

    <div class="row panel">
      <div class="title">Legend</div>
      <div class="help">
        • Space: Play/Stop • Click pads to toggle • Alt-click for Accent • Drag to paint • Keyboard for synth: ZSXDCVGBHNJ,M for lower, Q2W3ER5T6Y7UI for upper<br>
        • Wave: Square/Pulse/Triangle • Bits: 4–16 bit waveshaper for crunch • Glide: portamento • ADSR + low-pass filter + optional vibrato<br>
        • Tools: Randomize, Clear, Save to local storage, Load, Share (copies URL) • All audio runs in-browser via WebAudio; no assets needed.
      </div>
    </div>

    <div class="footer">CHIP-TRAX • 8-bit drum machine + synth • made with WebAudio</div>
  </div>

  <div id="toast" class="toast" role="status" aria-live="polite"></div>

<script>
(() => {
  // ===== Utility: DOM =====
  const $ = (sel, el=document) => el.querySelector(sel);
  const $$ = (sel, el=document) => Array.from(el.querySelectorAll(sel));
  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));

  function showToast(msg, ms=1200){
    const t = $('#toast');
    t.textContent = msg;
    t.classList.add('show');
    clearTimeout(t._t);
    t._t = setTimeout(()=> t.classList.remove('show'), ms);
  }

  // ===== Constants =====
  const NUM_STEPS = 16;
  const TRACKS = [
    {name:'KICK', color:'#62ff9b'},
    {name:'SNARE', color:'#ff2e8b'},
    {name:'HAT', color:'#00e0ff'},
    {name:'CLAP', color:'#ffd166'}
  ];

  // Pattern: 0=off, 1=on, 2=accent
  const pattern = Array.from({length: TRACKS.length}, () => Array(NUM_STEPS).fill(0));
  // Starter groove
  pattern[0] = [1,0,0,0, 1,0,0,0, 1,0,0,0, 1,0,0,0]; // Kick
  pattern[1] = [0,0,0,0, 2,0,0,0, 0,1,0,0, 2,0,0,0]; // Snare (with accents)
  pattern[2] = [1,1,1,1, 1,1,1,1, 1,1,1,1, 1,1,1,1]; // Hat
  pattern[3] = [0,0,0,0, 0,0,0,0, 1,0,0,0, 0,0,0,2]; // Clap

  // Track states (mute/solo)
  const trackState = TRACKS.map(()=>({mute:false, solo:false}));

  // ===== Audio State =====
  let audioCtx = null;
  let masterGain, comp;
  let drumGain, synthGain, synthCrusher, synthEnvGain, synthFilter;
  let lfoOsc, lfoGain;

  // Transport
  let isPlaying = false;
  let currentStep = 0;
  let nextNoteTime = 0; // seconds (context time)
  let schedulerTimer = null;
  let scheduleAheadTime = 0.10; // seconds
  let lookahead = 25; // ms
  let bpm = 120;
  let swingAmt = 0;
  let humanizeMs = 0;

  // Drum track volumes (per-track gain nodes)
  const trackGains = [];

  // Synth engine
  let synthOsc = null;
  let synthWaveType = 'square';
  let pulse25 = null, pulse125 = null;
  let bits = 8;
  let attack = 0.01, decay = 0.15, release = 0.20, sustain=0.6;
  let glide = 0.02;
  let octave = 0; // 0 => base C4 mapping
  let vibratoRate = 0, vibratoDepth = 0; // Hz, cents
  let synthPressed = new Set();
  let lastNote = null;

  // UI cache
  const gridEl = $('#grid');
  const gridHeadEl = $('#gridHead');
  const cellsByRowStep = []; // [r][s] => element
  let lastVisStep = null;

  // ===== Initialize Audio lazily =====
  function ensureAudio() {
    if (audioCtx) return;
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    masterGain = audioCtx.createGain();
    masterGain.gain.value = parseFloat($('#masterVol').value || '0.9');

    comp = audioCtx.createDynamicsCompressor();
    comp.threshold.value = -10;
    comp.ratio.value = 6;
    comp.attack.value = 0.003;
    comp.release.value = 0.2;

    masterGain.connect(comp).connect(audioCtx.destination);

    drumGain = audioCtx.createGain();
    drumGain.gain.value = 0.9;
    drumGain.connect(masterGain);

    synthGain = audioCtx.createGain();
    synthGain.gain.value = parseFloat($('#synthVol').value || '0.75');
    synthCrusher = audioCtx.createWaveShaper();
    synthCrusher.curve = makeBitCrusherCurve(bits);

    synthFilter = audioCtx.createBiquadFilter();
    synthFilter.type = 'lowpass';
    synthFilter.frequency.value = parseFloat($('#cut').value || '8000');
    synthFilter.Q.value = parseFloat($('#reso').value || '0.7');

    synthEnvGain = audioCtx.createGain();
    synthEnvGain.gain.value = 0.0;

    // Chain: osc -> env -> crusher -> filter -> synthGain -> master
    synthEnvGain.connect(synthCrusher).connect(synthFilter).connect(synthGain).connect(masterGain);

    // Per-track gains
    for (let i=0;i<TRACKS.length;i++){
      const g = audioCtx.createGain();
      g.gain.value = parseFloat($(`#vol${i}`).value);
      g.connect(drumGain);
      trackGains.push(g);
    }

    // Build pulse waves
    pulse25 = makePulseWave(0.25);
    pulse125 = makePulseWave(0.125);

    // Pre-warm synth oscillator (mono voice)
    initSynthOsc();

    // LFO for vibrato
    initSynthLFO();

    // Noise buffer for drums
    buildNoiseBuffer();
  }

  // ====== UI: Build Step Header ======
  function buildHead(){
    gridHeadEl.innerHTML = '';
    const lbl = document.createElement('div');
    lbl.className = 'track-name tiny';
    lbl.textContent = 'STEP';
    gridHeadEl.appendChild(lbl);
    for (let s=0; s<NUM_STEPS; s++){
      const head = document.createElement('div');
      head.className = 'step-head ' + (s%2===0 ? 'even' : 'odd');
      head.textContent = (s+1);
      gridHeadEl.appendChild(head);
    }
  }
  buildHead();

  // ====== UI: Build Grid ======
  function buildGrid(){
    gridEl.innerHTML = '';
    cellsByRowStep.length = 0;

    for (let r=0;r<TRACKS.length;r++){
      const name = document.createElement('div');
      name.className = 'track-name';
      const left = document.createElement('span');
      left.textContent = TRACKS[r].name;
      const ms = document.createElement('span');
      ms.className = 'ms';
      const mBtn = document.createElement('button');
      mBtn.className = 'toggle m';
      mBtn.textContent = 'M';
      mBtn.title = 'Mute';
      mBtn.addEventListener('click', () => {
        trackState[r].mute = !trackState[r].mute;
        mBtn.classList.toggle('active', trackState[r].mute);
      });

      const sBtn = document.createElement('button');
      sBtn.className = 'toggle s';
      sBtn.textContent = 'S';
      sBtn.title = 'Solo';
      sBtn.addEventListener('click', () => {
        trackState[r].solo = !trackState[r].solo;
        sBtn.classList.toggle('active', trackState[r].solo);
      });

      ms.appendChild(mBtn); ms.appendChild(sBtn);
      name.appendChild(left); name.appendChild(ms);
      gridEl.appendChild(name);

      const rowCells = [];
      for (let s=0;s<NUM_STEPS;s++){
        const cell = document.createElement('div');
        cell.className = 'cell ' + (s%2===0 ? 'even':'odd');
        cell.dataset.r = r; cell.dataset.s = s;

        const val = pattern[r][s] || 0;
        if (val>0) cell.classList.add('active');
        if (val===2) cell.classList.add('accent');

        gridEl.appendChild(cell);
        rowCells.push(cell);
      }
      cellsByRowStep.push(rowCells);
    }
    enableGridPainting();
  }
  buildGrid();

  // Painting interactions (click/drag, Alt=accent)
  function enableGridPainting(){
    let painting = false;
    let paintTo = null; // 0,1 or 2
    let accentMode = false;

    function applyToCell(cell){
      const r = parseInt(cell.dataset.r,10);
      const s = parseInt(cell.dataset.s,10);
      if (accentMode){
        // toggle accent on (2) or back to on (1)
        const curr = pattern[r][s];
        const newVal = (paintTo !== null) ? paintTo : (curr===2 ? 1 : 2);
        pattern[r][s] = newVal;
        cell.classList.toggle('active', newVal>0);
        cell.classList.toggle('accent', newVal===2);
      } else {
        const curr = pattern[r][s];
        const newVal = (paintTo !== null) ? paintTo : (curr>0 ? 0 : 1);
        pattern[r][s] = newVal;
        cell.classList.toggle('active', newVal>0);
        cell.classList.toggle('accent', newVal===2);
      }
    }

    gridEl.addEventListener('pointerdown', (e)=>{
      const target = e.target.closest('.cell');
      if (!target) return;
      painting = true;
      accentMode = e.altKey || e.metaKey;
      if (accentMode){
        // decide paintTo based on first cell
        const r = parseInt(target.dataset.r,10), s = parseInt(target.dataset.s,10);
        paintTo = (pattern[r][s]===2) ? 1 : 2;
      } else {
        const r = parseInt(target.dataset.r,10), s = parseInt(target.dataset.s,10);
        paintTo = (pattern[r][s]>0) ? 0 : 1;
      }
      applyToCell(target);
      e.preventDefault();
    });
    gridEl.addEventListener('pointerenter', (e)=>{
      if (!painting) return;
      const target = e.target.closest('.cell');
      if (target) applyToCell(target);
    }, true);
    window.addEventListener('pointerup', ()=>{
      if (painting){ painting = false; paintTo = null; }
    });
  }

  // ====== Transport Controls ======
  const playBtn = $('#playBtn');
  const tapBtn = $('#tapBtn');
  const bpmSlider = $('#bpm');
  const bpmNum = $('#bpmNum');
  const swingSlider = $('#swing');
  const swingTxt = $('#swingTxt');
  const humanSlider = $('#human');
  const humanTxt = $('#humanTxt');

  function setBPM(val){
    bpm = clamp(parseFloat(val)||120, 40, 240);
    bpmSlider.value = bpm;
    bpmNum.value = bpm;
  }
  bpmSlider.addEventListener('input', e => setBPM(e.target.value));
  bpmNum.addEventListener('input', e => setBPM(e.target.value));
  setBPM(120);

  function setSwing(val){
    swingAmt = clamp(parseFloat(val)||0, 0, 0.6);
    swingSlider.value = swingAmt;
    swingTxt.textContent = Math.round(swingAmt*100)+'%';
  }
  swingSlider.addEventListener('input', e => setSwing(e.target.value));
  setSwing(0);

  function setHuman(val){
    humanizeMs = clamp(parseFloat(val)||0, 0, 30);
    humanSlider.value = humanizeMs;
    humanTxt.textContent = Math.round(humanizeMs)+'ms';
  }
  humanSlider.addEventListener('input', e => setHuman(e.target.value));
  setHuman(0);

  $('#masterVol').addEventListener('input', e=>{
    ensureAudio();
    masterGain.gain.value = parseFloat(e.target.value);
  });

  playBtn.addEventListener('click', togglePlay);
  document.addEventListener('keydown', (e) => {
    if (e.code === 'Space' && !e.repeat && !isTyping(e)) {
      e.preventDefault();
      togglePlay();
    }
  });

  function togglePlay(){
    ensureAudio();
    audioCtx.resume();
    if (isPlaying){
      stop();
    } else {
      start();
    }
  }

  function start(){
    isPlaying = true;
    currentStep = 0;
    nextNoteTime = audioCtx.currentTime + 0.06;
    schedulerTimer = setInterval(scheduler, lookahead);
    playBtn.textContent = '■ Stop';
  }
  function stop(){
    isPlaying = false;
    clearInterval(schedulerTimer);
    schedulerTimer = null;
    playBtn.textContent = '▶ Play';
    clearPlayheads();
  }

  function clearPlayheads(){
    if (lastVisStep != null) {
      for (let r=0;r<TRACKS.length;r++){
        const cell = cellsByRowStep[r][lastVisStep];
        if (cell) cell.classList.remove('playing');
      }
      lastVisStep = null;
    }
  }

  // ===== Tap Tempo =====
  const tapTimes = [];
  let tapTimeout = null;
  tapBtn.addEventListener('click', ()=>{
    const now = performance.now();
    tapTimes.push(now);
    if (tapTimes.length > 6) tapTimes.shift();
    if (tapTimes.length >= 2){
      const intervals = [];
      for (let i=1; i<tapTimes.length; i++){
        intervals.push(tapTimes[i] - tapTimes[i-1]);
      }
      const avg = intervals.slice(-4).reduce((a,b)=>a+b,0) / Math.min(4, intervals.length);
      const newBpm = clamp(60000/avg, 40, 240);
      setBPM(newBpm.toFixed(0));
    }
    clearTimeout(tapTimeout);
    tapTimeout = setTimeout(()=> tapTimes.length=0, 1500);
  });

  // ====== Drum Scheduler ======
  function scheduler(){
    const spb = 60.0 / bpm;
    const stepDur = spb / 4.0; // 16ths

    while (audioCtx && nextNoteTime < audioCtx.currentTime + scheduleAheadTime){
      scheduleStep(currentStep, nextNoteTime);

      // advance time with swing
      let swingDelta = (currentStep % 2 === 0) ? stepDur * (1 - swingAmt) : stepDur * (1 + swingAmt);
      nextNoteTime += swingDelta;

      currentStep = (currentStep + 1) % NUM_STEPS;
    }
  }

  function anySolo(){
    return trackState.some(t=>t.solo);
  }

  function scheduleStep(stepIndex, time){
    // Trigger drums
    for (let r=0;r<TRACKS.length;r++){
      const val = pattern[r][stepIndex];
      if (val>0){
        // honor M/S
        if (trackState[r].mute) continue;
        if (anySolo() && !trackState[r].solo) continue;

        const accentMul = (val===2) ? 1.5 : 1.0;
        // Humanize time jitter (+/- humanizeMs)
        const jitter = (humanizeMs>0) ? ((Math.random()*2-1) * (humanizeMs/1000)) : 0;
        triggerDrum(r, time + jitter, accentMul);
      }
    }

    // Visual playhead aligned to audio
    const uiDelay = Math.max(0, (time - audioCtx.currentTime) * 1000 - 2);
    setTimeout(() => {
      if (lastVisStep != null){
        for (let r=0;r<TRACKS.length;r++){
          const prevCell = cellsByRowStep[r][lastVisStep];
          if (prevCell) prevCell.classList.remove('playing');
        }
      }
      for (let r=0;r<TRACKS.length;r++){
        const cell = cellsByRowStep[r][stepIndex];
        if (cell) cell.classList.add('playing');
      }
      lastVisStep = stepIndex;
    }, uiDelay);
  }

  // ====== Drum Voices ======
  let noiseBuffer = null;
  function buildNoiseBuffer(){
    const length = audioCtx.sampleRate * 2; // 2 seconds
    const buffer = audioCtx.createBuffer(1, length, audioCtx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i=0;i<length;i++){
      data[i] = Math.random()*2 - 1;
    }
    noiseBuffer = buffer;
  }

  function triggerDrum(track, time, accentMul){
    switch(track){
      case 0: playKick(time, trackGains[0], accentMul); break;
      case 1: playSnare(time, trackGains[1], accentMul); break;
      case 2: playHat(time, trackGains[2], accentMul); break;
      case 3: playClap(time, trackGains[3], accentMul); break;
    }
  }

  function playKick(time, outNode, mul=1){
    const osc = audioCtx.createOscillator();
    osc.type = 'triangle';
    const gain = audioCtx.createGain();
    const vJit = 1 + (humanizeMs>0 ? (Math.random()*0.12-0.06) : 0); // ±6%
    gain.gain.setValueAtTime(1.0 * mul * vJit, time);
    gain.gain.exponentialRampToValueAtTime(0.001, time + 0.22);

    osc.frequency.setValueAtTime(160, time);
    osc.frequency.exponentialRampToValueAtTime(50, time + 0.22);

    osc.connect(gain).connect(outNode);
    osc.start(time);
    osc.stop(time + 0.23);
  }

  function playSnare(time, outNode, mul=1){
    const src = audioCtx.createBufferSource();
    src.buffer = noiseBuffer;
    const bp = audioCtx.createBiquadFilter();
    bp.type = 'bandpass';
    bp.frequency.value = 1800;
    bp.Q.value = 0.7;

    const hp = audioCtx.createBiquadFilter();
    hp.type = 'highpass';
    hp.frequency.value = 800;

    const gain = audioCtx.createGain();
    const vJit = 1 + (humanizeMs>0 ? (Math.random()*0.18-0.09) : 0); // ±9%
    gain.gain.setValueAtTime(0.9 * mul * vJit, time);
    gain.gain.exponentialRampToValueAtTime(0.0001, time + 0.18);

    src.connect(bp).connect(hp).connect(gain).connect(outNode);
    src.start(time);
    src.stop(time + 0.2);
  }

  function playHat(time, outNode, mul=1){
    const src = audioCtx.createBufferSource();
    src.buffer = noiseBuffer;

    const hp = audioCtx.createBiquadFilter();
    hp.type = 'highpass';
    hp.frequency.value = 6000;
    hp.Q.value = 0.7;

    const gain = audioCtx.createGain();
    const vJit = 1 + (humanizeMs>0 ? (Math.random()*0.2-0.1) : 0); // ±10%
    gain.gain.setValueAtTime(0.5 * mul * vJit, time);
    gain.gain.exponentialRampToValueAtTime(0.0001, time + 0.06);

    src.connect(hp).connect(gain).connect(outNode);
    src.start(time);
    src.stop(time + 0.07);
  }

  function playClap(time, outNode, mul=1){
    // simple clap: 3 quick noise bursts
    const burstTimes = [0, 0.015, 0.030];
    for (const dt of burstTimes){
      const t = time + dt;
      const src = audioCtx.createBufferSource();
      src.buffer = noiseBuffer;

      const bp = audioCtx.createBiquadFilter();
      bp.type = 'bandpass';
      bp.frequency.value = 1500;
      bp.Q.value = 0.8;

      const gain = audioCtx.createGain();
      const vJit = 1 + (humanizeMs>0 ? (Math.random()*0.2-0.1) : 0);
      gain.gain.setValueAtTime(0.7 * mul * vJit, t);
      gain.gain.exponentialRampToValueAtTime(0.0001, t + 0.12);

      src.connect(bp).connect(gain).connect(outNode);
      src.start(t);
      src.stop(t + 0.13);
    }
  }

  // ====== Pulse waves (PeriodicWave) ======
  function makePulseWave(width){
    // width in (0,1); 0.5 is square.
    const harmonics = 64;
    const real = new Float32Array(harmonics+1);
    const imag = new Float32Array(harmonics+1);
    real[0] = 0;
    for (let n=1;n<=harmonics;n++){
      // Fourier series of pulse wave: only sine terms
      imag[n] = (2/(n*Math.PI)) * Math.sin(n*Math.PI*width);
      real[n] = 0;
    }
    return audioCtx.createPeriodicWave(real, imag, {disableNormalization:true});
  }

  function makeBitCrusherCurve(bits){
    const n = 1 << 16;
    const curve = new Float32Array(n);
    const levels = Math.pow(2, bits);
    for (let i=0;i<n;i++){
      const x = (i/(n-1)) * 2 - 1;
      const y = Math.round((x + 1) * 0.5 * (levels-1)) / (levels-1) * 2 - 1;
      curve[i] = y;
    }
    return curve;
  }

  // ====== Synth Engine ======
  function initSynthOsc(){
    if (synthOsc) return;
    synthOsc = audioCtx.createOscillator();
    updateOscWave(); // set periodic/shape
    // default frequency (C4)
    synthOsc.frequency.setValueAtTime(261.6256, audioCtx.currentTime);
    synthOsc.connect(synthEnvGain);
    synthOsc.start();

    // Attach LFO if it's ready
    if (lfoGain){
      try { lfoGain.disconnect(); } catch(e){}
      lfoGain.connect(synthOsc.detune);
    }
  }

  function initSynthLFO(){
    if (lfoOsc) return;
    lfoOsc = audioCtx.createOscillator();
    lfoOsc.type = 'sine';
    lfoGain = audioCtx.createGain();
    lfoGain.gain.value = 0; // cents
    lfoOsc.connect(lfoGain);
    if (synthOsc) lfoGain.connect(synthOsc.detune);
    lfoOsc.frequency.value = vibratoRate;
    lfoOsc.start();
  }

  function updateOscWave(){
    if (!synthOsc) return;
    switch(synthWaveType){
      case 'square':
        synthOsc.type = 'square';
        break;
      case 'pulse25':
        synthOsc.setPeriodicWave(pulse25);
        break;
      case 'pulse125':
        synthOsc.setPeriodicWave(pulse125);
        break;
      case 'triangle':
        synthOsc.type = 'triangle';
        break;
    }
  }

  function noteFrequency(semitoneFromC4){
    const base = 261.6255653005986; // C4
    return base * Math.pow(2, semitoneFromC4/12);
  }

  function synthNoteOn(semi){
    ensureAudio();
    audioCtx.resume();
    initSynthOsc();
    initSynthLFO();

    lastNote = semi;
    // Glide using setTargetAtTime
    const now = audioCtx.currentTime;
    const targetFreq = noteFrequency(semi + octave*12);
    const tc = Math.max(0.0001, glide);
    synthOsc.frequency.setTargetAtTime(targetFreq, now, tc);

    // Envelope
    const currentGain = synthEnvGain.gain.value;
    const atk = Math.max(0.001, attack);
    synthEnvGain.gain.cancelScheduledValues(now);
    if (currentGain < 0.01){
      synthEnvGain.gain.setValueAtTime(0.0001, now);
    } else {
      // Mini duck to avoid clicks on legato
      synthEnvGain.gain.setTargetAtTime(0.15, now, 0.005);
    }
    synthEnvGain.gain.linearRampToValueAtTime(1.0, now + atk);
    // Decay towards sustain
    synthEnvGain.gain.exponentialRampToValueAtTime(Math.max(0.001, sustain), now + atk + Math.max(0.005, decay));
  }

  function synthNoteOff(){
    if (!audioCtx) return;
    const now = audioCtx.currentTime;
    const rel = Math.max(0.001, release);
    synthEnvGain.gain.cancelScheduledValues(now);
    synthEnvGain.gain.setTargetAtTime(0.0001, now, rel/3);
  }

  // ====== Controls: Synth ======
  $('#waveSel').addEventListener('change', e => {
    synthWaveType = e.target.value;
    if (!audioCtx) return;
    updateOscWave();
  });
  $('#att').addEventListener('input', e => attack = parseFloat(e.target.value));
  $('#dec').addEventListener('input', e => decay = parseFloat(e.target.value));
  $('#sus').addEventListener('input', e => sustain = clamp(parseFloat(e.target.value),0,1));
  $('#rel').addEventListener('input', e => release = parseFloat(e.target.value));
  $('#glide').addEventListener('input', e => glide = parseFloat(e.target.value));
  $('#bits').addEventListener('input', e => {
    bits = parseInt(e.target.value,10);
    if (!audioCtx) return;
    synthCrusher.curve = makeBitCrusherCurve(bits);
  });
  $('#cut').addEventListener('input', e => { if (synthFilter) synthFilter.frequency.value = parseFloat(e.target.value); });
  $('#reso').addEventListener('input', e => { if (synthFilter) synthFilter.Q.value = parseFloat(e.target.value); });
  $('#vibRate').addEventListener('input', e => {
    vibratoRate = parseFloat(e.target.value);
    if (lfoOsc) lfoOsc.frequency.value = vibratoRate;
  });
  $('#vibDepth').addEventListener('input', e => {
    vibratoDepth = parseFloat(e.target.value);
    if (lfoGain) lfoGain.gain.value = vibratoDepth; // cents
  });
  $('#oct').addEventListener('input', e => octave = clamp(parseInt(e.target.value,10)||0, -2, 3));
  $('#synthVol').addEventListener('input', e => { ensureAudio(); synthGain.gain.value = parseFloat(e.target.value) });

  // ====== Controls: Drum pattern utilities ======
  $('#randomizeBtn').addEventListener('click', () => {
    const density = [0.7, 0.45, 0.85, 0.35]; // Kick, Snare, Hat, Clap
    for (let r=0;r<TRACKS.length;r++){
      for (let s=0;s<NUM_STEPS;s++){
        let base = density[r] * (s % 4 === 0 ? 1.1 : 0.9) * (s % 8 === 0 ? 1.15 : 1.0);
        const on = Math.random() < base;
        const acc = on && Math.random() < 0.18 ? 2 : (on?1:0);
        pattern[r][s] = acc;
        const cell = cellsByRowStep[r][s];
        cell.classList.toggle('active', acc>0);
        cell.classList.toggle('accent', acc===2);
      }
    }
  });

  $('#clearBtn').addEventListener('click', () => {
    for (let r=0;r<TRACKS.length;r++){
      for (let s=0;s<NUM_STEPS;s++){
        pattern[r][s] = 0;
        const cell = cellsByRowStep[r][s];
        cell.classList.remove('active', 'accent');
      }
    }
  });

  for (let i=0;i<TRACKS.length;i++){
    $(`#vol${i}`).addEventListener('input', e => {
      ensureAudio();
      if (trackGains[i]) trackGains[i].gain.value = parseFloat(e.target.value);
    });
  }

  // ====== Keyboard mapping ======
  // Lower row (Z row): Z S X D C V G B H N J M , => C to C
  // Upper row (Q row): Q 2 W 3 E R 5 T 6 Y 7 U I => C to E above
  const keyMap = {
    'z':0, 's':1, 'x':2, 'd':3, 'c':4, 'v':5, 'g':6, 'b':7, 'h':8, 'n':9, 'j':10, 'm':11, ',':12,
    'q':12, '2':13, 'w':14, '3':15, 'e':16, 'r':17, '5':18, 't':19, '6':20, 'y':21, '7':22, 'u':23, 'i':24
  };

  function isTyping(e){
    const t = e.target;
    return t && (t.tagName === 'INPUT' || t.tagName === 'SELECT' || t.tagName === 'TEXTAREA' || t.isContentEditable);
  }

  document.addEventListener('keydown', (e) => {
    if (isTyping(e)) return;
    const k = e.key.toLowerCase();
    if (keyMap.hasOwnProperty(k) && !e.repeat){
      const semi = keyMap[k];
      synthPressed.add(k);
      synthNoteOn(semi);
      blinkKeyUI(semi % 12, true);
    }
  });

  document.addEventListener('keyup', (e) => {
    if (isTyping(e)) return;
    const k = e.key.toLowerCase();
    if (keyMap.hasOwnProperty(k)){
      synthPressed.delete(k);
      blinkKeyUI(keyMap[k] % 12, false);
      // If no keys held, release
      if (synthPressed.size === 0){
        synthNoteOff();
      } else {
        // Retarget to last pressed
        const last = Array.from(synthPressed).at(-1);
        if (last){
          lastNote = keyMap[last];
          const now = audioCtx.currentTime;
          const targetFreq = noteFrequency(lastNote + octave*12);
          synthOsc.frequency.setTargetAtTime(targetFreq, now, Math.max(0.0001, glide));
        }
      }
    }
  });

  // ====== Clickable on-screen keys ======
  // Build a single octave UI dynamically (C..B), with black keys overlayed
  function layoutKeyboard(){
    const wrap = $('#kbwrap');
    wrap.innerHTML = '';
    const whiteKeyOrder = [0,2,4,5,7,9,11];
    const positions = [0,1,2,3,4,5,6]; // white key slots
    const whiteW = 40+6; // width+gap
    const kbW = positions.length * whiteW - 6;
    wrap.style.width = kbW+'px';

    // place whites
    whiteKeyOrder.forEach((semi,i)=>{
      const key = document.createElement('div');
      key.className = 'key kb-note white';
      key.dataset.note = semi.toString();
      key.style.left = (i*whiteW)+'px';
      key.style.top = '8px';
      key.style.width = '40px';
      key.style.height = '140px';
      wrap.appendChild(key);
    });

    // black keys (skip between E-F (index 2->3 in whites) and B-C (6->wrap))
    const blackMap = [
      {semi:1, pos:0, offset:30},
      {semi:3, pos:1, offset:30},
      {semi:6, pos:3, offset:30},
      {semi:8, pos:4, offset:30},
      {semi:10,pos:5, offset:30},
    ];
    blackMap.forEach(({semi,pos,offset})=>{
      const key = document.createElement('div');
      key.className = 'key black kb-note';
      key.dataset.note = semi.toString();
      key.style.left = (pos*whiteW + offset)+'px';
      key.style.top = '8px';
      key.style.width = '28px';
      key.style.height = '92px';
      wrap.appendChild(key);
    });

    // pointer handlers
    $$('.kb-note', wrap).forEach(el => {
      const semiInOct = parseInt(el.dataset.note,10); // 0..11
      let downed = false;

      const down = (ev) => {
        if (downed) return;
        downed = true;
        el.classList.add('down');
        synthNoteOn(semiInOct);
        window.addEventListener('pointerup', up, {once:true});
        window.addEventListener('mouseup', up, {once:true});
        ev.preventDefault();
      };
      const up = () => {
        if (!downed) return;
        downed = false;
        el.classList.remove('down');
        synthNoteOff();
      };
      el.addEventListener('pointerdown', down);
      el.addEventListener('mousedown', down);
      el.addEventListener('touchstart', (e)=>{ down(e); }, {passive:false});
    });
  }
  layoutKeyboard();

  function blinkKeyUI(semiInOct, down){
    const el = $(`.kb-note[data-note="${semiInOct}"]`);
    if (el){
      if (down) el.classList.add('down'); else el.classList.remove('down');
    }
  }

  // ===== Save / Load / Share =====
  function getState(){
    return {
      v:2,
      bpm, swingAmt, humanizeMs,
      pattern,
      volumes: trackGains.length ? trackGains.map((g,i)=>g.gain.value) : [parseFloat($('#vol0').value), parseFloat($('#vol1').value), parseFloat($('#vol2').value), parseFloat($('#vol3').value)],
      trackState,
      synth: {
        wave: synthWaveType, attack, decay, sustain, release, glide, bits, octave,
        vibRate: vibratoRate, vibDepth: vibratoDepth,
        cutoff: synthFilter ? synthFilter.frequency.value : parseFloat($('#cut').value),
        reso: synthFilter ? synthFilter.Q.value : parseFloat($('#reso').value),
        vol: synthGain ? synthGain.gain.value : parseFloat($('#synthVol').value)
      },
      master: masterGain ? masterGain.gain.value : parseFloat($('#masterVol').value)
    };
  }

  function applyState(st){
    try{
      if (!st) return;
      if (typeof st.bpm === 'number') setBPM(st.bpm);
      if (typeof st.swingAmt === 'number') setSwing(st.swingAmt);
      if (typeof st.humanizeMs === 'number') setHuman(st.humanizeMs);

      if (Array.isArray(st.pattern) && st.pattern.length === TRACKS.length){
        for (let r=0;r<TRACKS.length;r++){
          for (let s=0;s<NUM_STEPS;s++){
            const v = clamp((st.pattern[r][s]||0)|0, 0, 2);
            pattern[r][s] = v;
            const cell = cellsByRowStep[r][s];
            cell.classList.toggle('active', v>0);
            cell.classList.toggle('accent', v===2);
          }
        }
      }

      if (Array.isArray(st.volumes)){
        st.volumes.forEach((v,i)=>{
          const val = clamp(parseFloat(v)||0, 0, 1);
          const el = $(`#vol${i}`); if (el) el.value = val;
          if (trackGains[i]) trackGains[i].gain.value = val;
        });
      }

      if (Array.isArray(st.trackState)){
        st.trackState.forEach((ts,i)=>{
          if (!ts) return;
          trackState[i].mute = !!ts.mute;
          trackState[i].solo = !!ts.solo;
          // reflect buttons
          const rowName = gridEl.children[i*(NUM_STEPS+1)];
          const btns = $$('.toggle', rowName);
          if (btns[0]) btns[0].classList.toggle('active', trackState[i].mute); // M
          if (btns[1]) btns[1].classList.toggle('active', trackState[i].solo); // S
        });
      }

      if (st.synth){
        const s = st.synth;
        if (s.wave) { $('#waveSel').value = s.wave; synthWaveType = s.wave; updateOscWave(); }
        if (typeof s.attack === 'number'){ attack = s.attack; $('#att').value = s.attack; }
        if (typeof s.decay === 'number'){ decay = s.decay; $('#dec').value = s.decay; }
        if (typeof s.sustain === 'number'){ sustain = clamp(s.sustain,0,1); $('#sus').value = sustain; }
        if (typeof s.release === 'number'){ release = s.release; $('#rel').value = s.release; }
        if (typeof s.glide === 'number'){ glide = s.glide; $('#glide').value = s.glide; }
        if (typeof s.bits === 'number'){ bits = s.bits; $('#bits').value = s.bits; ensureAudio(); synthCrusher.curve = makeBitCrusherCurve(bits); }
        if (typeof s.octave === 'number'){ octave = s.octave; $('#oct').value = s.octave; }
        if (typeof s.vibRate === 'number'){ vibratoRate = s.vibRate; $('#vibRate').value = vibratoRate; if (lfoOsc) lfoOsc.frequency.value = vibratoRate; }
        if (typeof s.vibDepth === 'number'){ vibratoDepth = s.vibDepth; $('#vibDepth').value = vibratoDepth; if (lfoGain) lfoGain.gain.value = vibratoDepth; }
        if (typeof s.cutoff === 'number'){ $('#cut').value = s.cutoff; ensureAudio(); synthFilter.frequency.value = s.cutoff; }
        if (typeof s.reso === 'number'){ $('#reso').value = s.reso; ensureAudio(); synthFilter.Q.value = s.reso; }
        if (typeof s.vol === 'number'){ $('#synthVol').value = s.vol; ensureAudio(); synthGain.gain.value = s.vol; }
      }

      if (typeof st.master === 'number'){ $('#masterVol').value = st.master; ensureAudio(); masterGain.gain.value = st.master; }

      showToast('Loaded');
    }catch(err){
      console.error(err);
      showToast('Load failed', 1200);
    }
  }

  $('#saveBtn').addEventListener('click', ()=>{
    const state = getState();
    localStorage.setItem('chiptrax_state_v2', JSON.stringify(state));
    showToast('Saved');
  });

  $('#loadBtn').addEventListener('click', ()=>{
    const txt = localStorage.getItem('chiptrax_state_v2');
    if (!txt) return showToast('Nothing saved');
    const state = JSON.parse(txt);
    applyState(state);
  });

  $('#shareBtn').addEventListener('click', async ()=>{
    const state = getState();
    const payload = btoa(unescape(encodeURIComponent(JSON.stringify(state))));
    const url = location.origin + location.pathname + '#s=' + payload;
    try{
      await navigator.clipboard.writeText(url);
      showToast('Link copied');
    }catch(e){
      location.hash = 's=' + payload;
      showToast('Link set in URL');
    }
  });

  // Load from URL hash if present
  (function loadFromHash(){
    const h = location.hash;
    const m = h.match(/#s=([^&]+)/);
    if (!m) return;
    try{
      const json = decodeURIComponent(escape(atob(m[1])));
      const state = JSON.parse(json);
      applyState(state);
      showToast('Preset loaded from link', 1000);
    }catch(e){
      console.warn('Failed to load state from hash', e);
    }
  })();

  // ====== Random Helpful: prevent context menu on long-press ======
  document.addEventListener('contextmenu', e => e.preventDefault());

  // ====== Build initial audio lazily on first interaction ======
  // Minor: resume audio on user click anywhere
  window.addEventListener('pointerdown', ()=>{ try{ ensureAudio(); audioCtx.resume(); }catch(e){} }, {once:true});

})();
</script>
</body>
</html>